\chapter{Development Process}
Due to a strict deadline and extensive possibilities the project offered it is important to choose a development life cycle that could both quick and flexible. It needed to be able to allow for rapid development in a controlled manor that would reduce the need for rewriting and refactoring of code. Therefore the methodology will revolve around an iterative life cycle. As the project is easily broken down into a small number of well formed sections these iterations are able to be well formed before development beings.

My development method will consist of taking the project and breaking it into smaller segments that can be tackled individually. Each segment will contain a planning, development and analysis stage. The development will take place iteratively building on prototypes to produce the final component. This will avoid making throwaway prototypes and cut down on development time. These segments will build upon the ones before, building up a complete working application. This combines different aspects from both the Spiral and Rapid application development (R.A.D) methodologies.

A weekly plan has been set out that is currently up until mid-January 2013. It covers the major aspects and milestones of the project as well due dates for each hand in. At the time of writing the first two sections, mapping solutions and location services have both been completed comfortably within time. The next stage is to research, prototype different client-server communication methods. Writing up my findings and implementing the basis of my chosen method. After getting the basic client-server interactions working it will be a case of adding features to each and adding the required supporting system to the other. Adding features until a basic working prototype is ready for testing which I plan to be at the end of November during the last week of term. This basic prototype aims to locate each user and display their location on every users device. It will be an important test on such things as responsiveness, battery usage and server stability and load. Testing will take the form of distributing my test application to a number of testers who will spread out and walk around the local area. Detailed logs will be take on each device storing different hardware events, such as GPS updates and battery statuses, as well as all sent and received data from the server. Also the server and proxy will log all the connections received and responded to as well as their loads at various intervals.

\section{Introduction}
The development life cycle chosen is that of Rapid Application Development (RAD). This process reduces the need to have a detailed specification or design at the beginning of development. Instead specification, design and implementation are all simultaneous. This life cycle follows more closely to the Spiral Model than that of a more traditional waterfall type life cycle. The Spiral Model, as defined by Barry Boehm\cite{spiral_model}, depicts an evolutionary style of development which still keeps control over the project. Unlike the waterfall model which requires a stringent and detailed design that needs to be followed throughout implementation. Only the highest-priority features are considered for each iteration. The chosen feature is defined, designed and implemented during the cycle. Each cycle results in a prototype of a portion of the final system that can be tested. From this prototype ideas can be tweaked and changed then defined and implemented. Then the next feature can be defined and so on until the desired system is completed.

The RAD life cycle is a further streamlining of the spiral model and only has four distinct stages. Firstly there is the requirements gathering stage where all parties agree on the scope and requirements for the overall project. This is followed by user design where users interact with the developers and create a set of prototypes that are then evaluated by the users. This step is continuous phase that sees the prototypes change and adapt to the users requirements. This phase works in tandem with the construction phase which sees the prototypes be integrated into the final application and tested. With the user still actively involved they can suggest changes and improvements as the application takes shape. After the application is completed the final stage sees its testing, integration and user training.


\section{Modifications}
The spiral and RAD models are defined as an evolutionary method therefore each iteration prototype should be delivered to the stakeholders. These stakeholders can then give their feedback which should be utilized in the next cycle. Seeing as this project does not have any stakeholders this crucial step can not be completed and therefore the model needed to be adapted from a evolutionary to an incremental one. To achieve this the stages were mapped out before implementation began resulting in a slightly increased amount of design. These stages were purposefully left as broad as possible to accommodate necessary changes that would present themselves as development began.

As well as removing the of reworking code by cutting out the feedback loop for each prototype, the user design and construction phases are combined. This single step would see prototypes being worked directly into the current code base. In this way extra development time would not need to be used to integrate the prototype back into the master branch. This combination by itself would slowly reduce the code quality seen across the application as ideas are tested, for this reason spike work is encouraged to be carried out before each iteration. These short spike work sessions should show up any problems and highlight more efficient ways that part of code could be implemented. This will then carry over into the main code when the feature is implemented. It is important to keep this spike work short and focused and full solutions are not the ideal outcome from it.

These modifications were made as a way to streamline development, reducing time spent in design and coding while not reducing code quality or flexibility.




\section{Development Environment}
Development on the Android platform restricts development to Java using the Android SDK. It was decided to use the Eclipse IDE as the main editor partly due to it's popularity and abundance of information and also it's improved integration with the SDK. Google provide an Eclipse plugin called Android Development Tools (ADT) which provide a set of tools to streamline the development process. 



The server portion of the project was written in Python this was mainly to speed up development and minimize unforeseen problems. Python is a general purpose high-level programming language that has a small learning curve and generally produces concise code.