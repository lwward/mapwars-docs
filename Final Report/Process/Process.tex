\chapter{Development Process}
Due to a strict deadline and extensive possibilities the project offered it is important to choose a development life cycle that could both quick and flexible. It needed to be able to allow for rapid development in a controlled manor that would reduce the need for rewriting and refactoring of code. Therefore the methodology will revolve around an iterative life cycle. As the project is easily broken down into a small number of well formed sections these iterations are able to be well formed before development beings.

\section{Introduction}
The development life cycle chosen is that of Rapid Application Development (RAD). This process reduces the need to have a detailed specification or design at the beginning of development. Instead specification, design and implementation are all simultaneous. This life cycle follows more closely to the Spiral Model than that of a more traditional waterfall type life cycle. The Spiral Model, as defined by Barry Boehm\cite{spiral_model}, depicts an evolutionary style of development which still keeps control over the project. Unlike the waterfall model which requires a stringent and detailed design that needs to be followed throughout implementation. Only the highest-priority features are considered for each iteration. The chosen feature is defined, designed and implemented during the cycle. Each cycle results in a prototype of a portion of the final system that can be tested. From this prototype ideas can be tweaked and changed then defined and implemented. Then the next feature can be defined and so on until the desired system is completed.

The RAD life cycle is a further streamlining of the spiral model and only has four distinct stages. Firstly there is the requirements gathering stage where all parties agree on the scope and requirements for the overall project. This is followed by user design where users interact with the developers and create a set of prototypes that are then evaluated by the users. This step is continuous phase that sees the prototypes change and adapt to the users requirements. This phase works in tandem with the construction phase which sees the prototypes be integrated into the final application and tested. With the user still actively involved they can suggest changes and improvements as the application takes shape. After the application is completed the final stage sees its testing, integration and user training.


\section{Modifications}
The spiral and RAD models are defined as an evolutionary method therefore each iteration prototype should be delivered to the stakeholders. These stakeholders can then give their feedback which should be utilized in the next cycle. Seeing as this project does not have any stakeholders this crucial step can not be completed and therefore the model needed to be adapted from a evolutionary to an incremental one. To achieve this the stages were mapped out before implementation began resulting in a slightly increased amount of design. These stages were purposefully left as broad as possible to accommodate necessary changes that would present themselves as development began.

As well as removing the of reworking code by cutting out the feedback loop for each prototype, the user design and construction phases are combined. This single step would see prototypes being worked directly into the current code base. In this way extra development time would not need to be used to integrate the prototype back into the master branch. This combination by itself would slowly reduce the code quality seen across the application as ideas are tested, for this reason spike work is encouraged to be carried out before each iteration. These short spike work sessions should show up any problems and highlight more efficient ways that part of code could be implemented. This will then carry over into the main code when the feature is implemented. It is important to keep this spike work short and focused and full solutions are not the ideal outcome from it.

These modifications were made as a way to streamline development, reducing time spent in design and coding while not reducing code quality or flexibility.


\section{Development Environment}
It was decided to use the Eclipse IDE as the main editor partly due to it's popularity and abundance of information and also it's improved integration with the Android SDK. Google provide an Eclipse plugin called Android Development Tools (ADT) which provide a set of tools to streamline the development process. 

Eclipse was only selected for the Android portion of development for the reasons stated above, for the remainder of the coding and other things Sublime Text 2 was picked. It offers syntax highlighting for all the most common languages as well as a vast array of plugins and features to speed up development time.

Version control was handled by Git providing both data assurance and branching. Git was chosen over other systems, such as SVN and Perforce, offering a more versatile workflow allowing for local version control with changes being pushed to the master instead of other more centralized systems. To utilize Git to it's full potential a web-based hosting service was used to both host the code and to add extra features such as issue tracking and wiki-style documentation. Both BitBucket\footnote{\url{https://bitbucket.org/}} and GitHub\footnote{\url{https://github.com/}} were used initially but GitHub was favoured over it's more comprehensive set of tools. Particularly useful was the wiki that was automatically setup allowing for detailed documentation and research. GitHub also offers a number of visualisations to easily view commits history and network showing the different branches and merges.

The use of version control also helped with the rapid prototyping methodology by utilizing branching effectively. For each new feature being developed a new branch would be made where this development took place. Once development was complete these changes were tested and then merged back in to the master branch.

\subsection{Hardware}
Android offers a huge variety of hardware and is not just restricted to mobile phones. The OS can now be seen on tablets, set-top boxes, smart TVs and netbooks. However, mobile devices still have 96\% of the market share with tablets following being with 64\%, other devices only account for 20\% of the market. To match this and the expected target market development was focused on both mobile phones and tablets. Originally a Motorola Atrix (v2.3) was picked for the main development device but after the first few months a faulty digitizer demoted this to a test device. A HTC Sensation (v4.0) was procured to replace the Atrix as the primary device. Experimentation and implementation for bigger tablet sized devices was done on a Motorola Xoom 2 Media Edition (v4.0). Other testing devices include a Sony Ericsson ST25i (v2.3).

The main development machine was running a 64-bit Debian based OS. Server hardware of consisted a single virtual private server with 128MB RAM running Debian 5 32-bit.