\chapter{Development Process}
Due to a strict deadline and extensive possibilities the project offered it is important to choose a development life cycle that could both quick and flexible. It needed to be able to allow for rapid development in a controlled manor that would reduce the need for rewriting and refactoring of code. Therefore the methodology will revolve around an iterative life cycle. As the project is easily broken down into a small number of well formed sections these iterations are able to be well formed before development beings.

\section{Introduction}
The development life cycle chosen is that of Rapid Application Development (RAD). This process reduces the need to have a detailed specification or design at the beginning of development. Instead specification, design and implementation are all simultaneous. This life cycle follows more closely to the Spiral Model than that of a more traditional waterfall type life cycle. The Spiral Model, as defined by Barry Boehm\cite{spiral_model}, depicts an evolutionary style of development which still keeps control over the project. Unlike the waterfall model which requires a stringent and detailed design that needs to be followed throughout implementation. Only the highest-priority features are considered for each iteration. The chosen feature is defined, designed and implemented during the cycle. Each cycle results in a prototype of a portion of the final system that can be tested. From this prototype ideas can be tweaked and changed then defined and implemented. Then the next feature can be defined and so on until the desired system is completed.

The RAD life cycle is a further streamlining of the spiral model and only has four distinct stages. Firstly there is the requirements gathering stage where all parties agree on the scope and requirements for the overall project. This is followed by user design where users interact with the developers and create a set of prototypes that are then evaluated by the users. This step is continuous phase that sees the prototypes change and adapt to the users requirements. This phase works in tandem with the construction phase which sees the prototypes be integrated into the final application and tested. With the user still actively involved they can suggest changes and improvements as the application takes shape. After the application is completed the final stage sees its testing, integration and user training.


\section{Modifications}
The spiral and RAD models are defined as an evolutionary method therefore each iteration prototype should be delivered to the stakeholders. These stakeholders can then give their feedback which should be utilized in the next cycle. Seeing as this project does not have any stakeholders this crucial step can not be completed and therefore the model needed to be adapted from a evolutionary to an incremental one. To achieve this the stages were mapped out before implementation began resulting in a slightly increased amount of design. These stages were purposefully left as broad as possible to accommodate necessary changes that would present themselves as development began.

As well as removing the of reworking code by cutting out the feedback loop for each prototype, the user design and construction phases are combined. This single step would see prototypes being worked directly into the current code base. In this way extra development time would not need to be used to integrate the prototype back into the master branch. This combination by itself would slowly reduce the code quality seen across the application as ideas are tested, for this reason spike work is encouraged to be carried out before each iteration. These short spike work sessions should show up any problems and highlight more efficient ways that part of code could be implemented. This will then carry over into the main code when the feature is implemented. It is important to keep this spike work short and focused and full solutions are not the ideal outcome from it.

These modifications were made as a way to streamline development, reducing time spent in design and coding while not reducing code quality or flexibility.




\section{Development Environment}

\subsection{Language}
Java, Python

\subsection{Deveopment Environment}
Eclipse, sublime, GIT, GitHub

\subsection{Hardware}
Although the platform has been selected it is also important to examine the target devices.Android has began reaching much wider than just the phone market as it finds its way on to tablets, set-top boxes and netbooks.

Devices? 96\% Android phones, 64\%Table, remaining 20\% netbooks and TVs.

Phones, tablets, broken digitizer

\subsection{Other tools}
DIA?

Development on the Android platform restricts development to Java using the Android SDK. It was decided to use the Eclipse IDE as the main editor partly due to it's popularity and abundance of information and also it's improved integration with the SDK. Google provide an Eclipse plugin called Android Development Tools (ADT) which provide a set of tools to streamline the development process. 



The server portion of the project was written in Python this was mainly to speed up development and minimize unforeseen problems. Python is a general purpose high-level programming language that has a small learning curve and generally produces concise code.